name: Build, Test, and Publish

on:
  push:
    branches: [ master, dev ]

jobs:
  build_and_test:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.set_vars.outputs.version_number }}
    steps:
    - uses: actions/checkout@v4
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x
    - name: Set variables
      id: set_vars
      run: |
        BASE_VER=$(cat VERSION)
        MAJOR_MINOR=$(echo "$BASE_VER" | cut -d. -f1,2)
        VERSION_NUMBER="${MAJOR_MINOR}.${{ github.run_number }}"
        echo "VERSION=${VERSION_NUMBER}" >> $GITHUB_ENV
        echo "version_number=${VERSION_NUMBER}" >> $GITHUB_OUTPUT
    - name: Update version in files
      run: |
        sed -i 's/version = .*;/version = \"${{ env.VERSION }}\";/' ./SudokuSolver/Version.cs
        find . -type f -name '*.user.js' | xargs sed -i -E 's/(@version[ \t]*).*/\1${{ env.VERSION }}/'
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
    - name: Restore dependencies
      run: dotnet restore
    - name: Build
      run: dotnet build --nologo --configuration Release --no-restore
    - name: Test
      run: dotnet test --nologo --configuration Release --no-build --verbosity normal
    - name: Upload Workspace with Updated Versions
      uses: actions/upload-artifact@v4
      with:
        name: workspace
        path: . # Upload the whole workspace, including versioned files

  package:
    runs-on: ubuntu-latest
    needs: build_and_test
    strategy:
      matrix:
        include:
          # archive_ext is no longer needed here as we always produce a .zip via the upload action
          - os: ubuntu-latest
            rid: win-x64
            os_folder: Windows
            archive_filename_suffix: win-x64
          - os: ubuntu-latest
            rid: win-arm64
            os_folder: Windows
            archive_filename_suffix: win-arm64
          - os: ubuntu-latest
            rid: linux-x64
            os_folder: Linux
            archive_filename_suffix: linux-x64
          - os: macos-latest
            rid: osx-x64
            os_folder: OSX
            archive_filename_suffix: osx-x64
          - os: macos-latest
            rid: osx-arm64
            os_folder: OSX
            archive_filename_suffix: osx-arm64
    steps:
    - name: Download Workspace
      uses: actions/download-artifact@v4
      with:
        name: workspace
        path: .
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x
    - name: Set VERSION env var from job output
      run: echo "VERSION=${{ needs.build_and_test.outputs.version }}" >> $GITHUB_ENV
    - name: Debug env.VERSION
      run: |
        echo "DEBUG: env.VERSION is '${{ env.VERSION }}'"
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
    - name: Restore dependencies for publish
      run: dotnet restore
    - name: Publish ${{ matrix.rid }}
      run: dotnet publish ./SudokuSolverConsole/SudokuSolverConsole.csproj --nologo -c Release -r ${{ matrix.rid }} -p:PublishSingleFile=true --self-contained true --no-restore -o publish-${{ matrix.rid }}
    - name: Delete pdbs for ${{ matrix.rid }}
      run: rm -f ./publish-${{ matrix.rid }}/*.pdb
    - name: Prepare Package Directory for ${{ matrix.rid }}
      run: |
        PACKAGE_DIR="package-${{ matrix.rid }}"
        mkdir -p "$PACKAGE_DIR"

        # Ensure execute permissions for the published app if necessary (dotnet publish usually handles this)
        # For example, if your main executable is SudokuSolverConsole:
        # if [ -f "./publish-${{ matrix.rid }}/SudokuSolverConsole" ] && [[ "${{ matrix.rid }}" == *"osx"* || "${{ matrix.rid }}" == *"linux"* ]]; then
        #   chmod +x "./publish-${{ matrix.rid }}/SudokuSolverConsole"
        # fi

        cp -r ./publish-${{ matrix.rid }}/* "$PACKAGE_DIR/"

        if [ -d "./UserScripts" ] && [ -n "$(ls -A ./UserScripts 2>/dev/null)" ]; then
          cp -r ./UserScripts/* "$PACKAGE_DIR/"
        fi

        if [ -d "./${{ matrix.os_folder }}" ] && [ -n "$(ls -A ./${{ matrix.os_folder }} 2>/dev/null)" ]; then
          cp -r ./${{ matrix.os_folder }}/* "$PACKAGE_DIR/"
        fi
        echo "PACKAGE_DIR_PATH=$PACKAGE_DIR" >> $GITHUB_ENV # Output the directory path to be uploaded
        echo "Prepared package directory: $PACKAGE_DIR"
    - name: Notarize for ${{ matrix.rid }}
      if: startsWith(matrix.rid, 'osx-')
      run: |
        # macOS notarization

        # TODO install certificates from secrets

        API_KEY_PATH="${RUNNER_TEMP}/AuthKey_${{ secrets.MACOS_API_KEY_ID }}.p8"
        echo "${{ secrets.MACOS_API_KEY }}" | base64 --decode > "${API_KEY_PATH}"
        APP_PATH="./publish-${{ matrix.rid }}/SudokuSolverConsole"

        if [ ! -f "${APP_PATH}" ]; then
          echo "Failed to find the executable at ${APP_PATH}!"
          exit 1
        fi

        xcrun atool \
        --validate-app \
        --file "${APP_PATH}" \
        --type macos \
        --apiKey "${API_KEY_PATH}" \
        --apiIssuer "${{ secrets.MACOS_API_ISSUER_ID }}" \
        --verbose \
        --output-format json

        if [ $? -ne 0 ]; then
          echo "Notarization validation failed for ${{ matrix.rid }}"
          exit 1
        fi

        xcrun notarytool submit \
          --key "${API_KEY_PATH}" \
          --key-id "${{ secrets.MACOS_API_KEY_ID }}" \
          --issuer "${{ secrets.MACOS_API_ISSUER_ID }}" \
          --verbose \
          --wait \
          --output-format json \
          "${APP_PATH}"

        if [ $? -ne 0 ]; then
          echo "Notarization submission failed for ${{ matrix.rid }}"
          exit 1
        fi

        xcrun stapler staple \
          --verbose \
          "${APP_PATH}"

        if [ $? -ne 0 ]; then
          echo "Stapling notarization failed for ${{ matrix.rid }}"
          exit 1
        fi

    - name: Upload Artifact for ${{ matrix.rid }}
      id: upload_artifact_step
      uses: actions/upload-artifact@v4
      with:
        # The action will append .zip to this name as it's uploading a directory
        name: SudokuSolver-${{ env.VERSION }}-${{ matrix.archive_filename_suffix }}
        path: ${{ env.PACKAGE_DIR_PATH }} # Path to the directory to be zipped by the action
        if-no-files-found: error
    - name: Update Job Summary for ${{ matrix.rid }}
      if: always()
      shell: bash
      run: |
        RID_VAL="${{ matrix.rid }}"
        VERSION_VAL="${{ env.VERSION }}"
        STATUS_VAL="${{ job.status }}"
        UPLOAD_ARTIFACT_ID_VAL="${{ steps.upload_artifact_step.outputs.artifact-id }}"
        # Construct the artifact name as it will appear in the UI (action appends .zip)
        ARTIFACT_DISPLAY_NAME="SudokuSolver-$VERSION_VAL-${{ matrix.archive_filename_suffix }}.zip"

        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "### Package: \`$RID_VAL\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Version**: \`$VERSION_VAL\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Status**: \`$STATUS_VAL\`" >> $GITHUB_STEP_SUMMARY

        if [ "$STATUS_VAL" == "success" ] && [ -n "$UPLOAD_ARTIFACT_ID_VAL" ]; then
          ARTIFACT_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts/$UPLOAD_ARTIFACT_ID_VAL"
          echo "- **Artifact**: [$ARTIFACT_DISPLAY_NAME]($ARTIFACT_URL)" >> $GITHUB_STEP_SUMMARY
        else
          echo "- **Artifact Name**: \`$ARTIFACT_DISPLAY_NAME\` (Upload may have been skipped or failed if status is not success. Artifact ID: '$UPLOAD_ARTIFACT_ID_VAL')" >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY